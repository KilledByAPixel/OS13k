<!--

OS13k is a tiny operating system designed for a JS13k community project. It has native support for Shadertoys, Dweets, ZzFX, trophies, and much more.

Your mission, if you choose to accept it, is to help us fill it up with as much cool stuff as we can fit.

Please keep this project confidential!

‚úåÔ∏èüòÑ ‚ù§Ô∏è OS13k Team

-->

<title>OS13k - A Tiny JavaScript Operating System</title>
<link rel=icon type=image/x-icon href='favicon.ico'/>
<meta name=viewport content='width=device-width,initial-scale=1,user-scalable=0'>
<script src=programs.js?115></script>

<!-- HTML above is OPTIONAL -->

<meta charset=utf-8>
<style>
body
{
    opacity:0;
    margin:0;
    overflow:hidden;
    font-family:arial;
    font-size:22;
    user-select:none;
    white-space:nowrap;
    background:#000;
}
#menu
{
    display:flex;
    flex-direction:column;
    background:#000;
}
.programMenu { background:linear-gradient(#fff,#777); }
#menu, .programMenu
{
    visibility:hidden;
    position:absolute;
    z-index:20000;
    box-shadow:5px 5px 9px;
    border:2px solid;
}
.program
{
    font-size:18;
    height:18;
    padding:4;
}
.activeWindow { border:3px solid #aaa; }
#taskbar
{
    position:absolute;
    z-index:10000;
    width:100%;
    background:linear-gradient(#888,#333);
    box-shadow:0px 1px 9px;
    border:2px solid;
    left:-2;
}
.taskbarIcon { width:50; height:40; text-shadow:1px 1px 3px #000; }
.programActive,
.taskbarIconActive         { background:linear-gradient(#ff8,#fff); }
.taskbarIcon:hover         { background:linear-gradient(#fff,#44f); }
#tray
{
    margin:2;
    padding-left:9;
    padding-right:9;
    color:#fff;
    background:linear-gradient(#000,#333);
    border:1px solid;
    border-radius:6px;
    text-shadow:1px 1px 3px #000;
}
.trayIcon       { padding:2; }
.trayIcon:hover { background:#fff3; }
.popup
{
    position:relative;
    z-index:10000;
    width:200;
    padding:8;
    pointer-events:none;
    overflow:hidden;
    white-space:normal;
    text-align:center;
    background:linear-gradient(#eee,#888);
    box-shadow:9px 9px 19px;
    border:2px solid;
    border-radius:9px;
}
.trophyIcon
{
    padding:9;
    font-size:40;
    text-shadow:2px 2px 4px;
    white-space:nowrap;
}
#background
{
    position:absolute;
    width:100%;
    height:100%;
    color:#0002;
    font-family:impact;
    font-size:30vw;
    font-weight:900;
}
.program, #taskbar, .taskbarIcon, #background, #tray
{
    display:flex;
    align-items:center;
    justify-content:center;
}
</style>
<template id=T>
<style>
:host
{
    visibility:hidden;
    overflow:hidden;
    position:absolute;
    background:#000;
    box-shadow:5px 5px 9px;
    border:3px solid #222;
    border-radius:6px;
}
.titlebar
{
    height:34;
    font-size:24;
    display:flex;
    align-items:center;
    overflow:hidden;
    white-space:nowrap;
    background:linear-gradient(#ccc,#444);
    border-bottom:3px solid;
}
.titlebarActive { background:linear-gradient(#eee,#88f); }
.titlebarSticky { background:linear-gradient(#ccc,#844); }
#name           { width:100%; overflow:hidden; cursor:grab; }
#icon           
{ 
    display:inline;
    text-shadow:1px 1px 3px #000;
    margin-left:9;
    margin-right:9;
    pointer-events:none;
}
#frame
{
    width:100%;
    height:100%;
    background:#fff;
    border:none;
    visibility:hidden;
}
#codeDisplay
{
    width:100%;
    height:99;
    resize:none;
    display:none;
    background:#000;
    color:#fff;
    border:2px solid #fff;
    outline:0;
}
#full:hover   { background:#fff; }
#help:hover   { background:#0ff; }
#code:hover   { background:#f0f; }
#shrink:hover { background:#0ff; }
#grow:hover   { background:#0f0; }
#reload:hover { background:#ff0; }
#close:hover  { background:#f00; }
</style>
</template>
<div id=background></div>
<div id=desktop>
<div id=taskbar>
<div id=taskbarSpace style=flex:1></div>
<div id=tray></div>
</div>
<div id=popups style=float:right></div>
<div id=programsMenu style=position:absolute></div>
<div id=menu>
<button id=buttonFullScreen>Full Screen
<button id=buttonCode>Code
<button id=buttonHelp>Help
<button id=buttonResetSize>Reset Size
<button id=buttonReload>Reload
<button id=buttonClose>Close
<script>

'use strict';

///////////////////////////////////////////////////////////////////////////////
// OS13k Debug (remove from minified)

const OS13kVersion = 62;
{
    // version check, clear local storage if older
    if (localStorage.OS13kVersion && localStorage.OS13kVersion != OS13kVersion)
    {
        alert('OS13k version out of date! System reset in 3, 2, 1...');
        localStorage.clear();
    }

    localStorage.OS13kVersion = OS13kVersion;

    // load default programs if none found
    var programsDefault = 0;
    if (typeof programs == 'undefined')
    {
        alert('No programs found, using defaults!')

        var sticky=2**0, reload=2**1, awake=2**2, full=2**3, resize=2**4, code=2**5;
        var defaultFlags = full|reload|resize, defaultWidth = 720, defaultHeight = 405;
        var programs = 
        [
            [,'‚ùå',,,,'Close All'],
            ['help.html','<b><span style=color:#0f0>?',380,400,sticky],

            [,'‚öôÔ∏è',,,,'System',,
            [
                ['system/settings.html','üéöÔ∏è',470,160,sticky],
                ['system/trophyCase.html','üèÜ',,,resize|sticky],
                ['system/clock.dweet.js','üï∞Ô∏è',200,200,sticky|code|awake],
                ['system/systemTest.html',,600,370,defaultFlags|code],
            ]]
        ];
    }
} // debug stuff

///////////////////////////////////////////////////////////////////////////////
// Minification Stuff

{
// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @language_out ECMASCRIPT_2019
// @js_externs localStorage.OS13k, OS13k, iframeContent.zzfx
// @js_externs OS13k.Clamp, OS13k.Percent, OS13k.Lerp
// @js_externs OS13k.Random, OS13k.randomSeed, iframeContent.OS13kReload
// @js_externs OS13k.Trophies, OS13k.Trophy, OS13k.GetTrophy
// @js_externs OS13kSystem.Sound, OS13k.PlaySamples, OS13k.Note
// @js_externs OS13k.Speak, OS13k.StopSpeech, OS13k.PlaySeed
// @js_externs OS13k.Settings(), OS13k.SaveSettings()
// @js_externs OS13k.CreateShader, OS13k.RenderShader
// @js_externs OS13k.KeyDirection, OS13k.RemoveHTML, OS13k.Popup
// @output_file_name OS13k.min.js
// ==/ClosureCompiler==

// Minification Steps
// 1. Remove touch support and optional code
// 2. Paste programs directly below here
// 3. Remove optional stuff listed below
// 4. Verify that it works the same
// 5. HTML Minifier http://minifycode.com/html-minifier/
// 6. Google Closure https://closure-compiler.appspot.com/home
// 7. Terser no extra compression https://xem.github.io/terser-online/
// 8. Zip
// 9. Advzip "advzip -z -4 -i 1000 OS13kMin.zip"

// Rework stuff marked OPTIONAL for final build
// - all files must be packed together to save space
// - smaller webgl names r10215
// - move css into code, get rid of names
// - remoe system trophies

} // Minification Stuff

///////////////////////////////////////////////////////////////////////////////
// OS13k Client Interface

class _OS13k
{

/////////////////////////////////////////////////////////////////////////////
// OS13k Math

    Clamp   (a, min=0, max=1)  { return Math.min(Math.max(a, min), max); }
    Percent (v, a, b)          { return b-a ? this.Clamp((v-a)/(b-a), 0, 1) : 0; }
    Lerp    (p, a, b)          { return a + this.Clamp(p, 0, 1) * (b-a); }
    Random  (max=1, min=0)    
    {
        // seeded random numbers - Mersenne Twister
        this.randomSeed ^= (this.randomSeed||1) << 13;
        this.randomSeed ^= this.randomSeed >> 17;
        this.randomSeed ^= this.randomSeed << 5;
        return this.Percent(Math.abs(this.randomSeed) % 1e9 / 1e9, min, max);
    }

/////////////////////////////////////////////////////////////////////////////
// OS13k Trophies
    
    // get trophy list
    Trophies() { return [...trophies]; }

    // award player with trophy, returns 0 if already owned
    Trophy(game='', icon='', name='', message='', language='ja')
    {
        // replace commas and apostrophes
        const Clean=string=>(string+'').replace(/`/g, "'").replace(/,/g, '');
        game    = Clean(game);
        name    = Clean(name);
        icon    = Clean(icon);
        message = Clean(message);
        
        // remove html tags
        icon    = this.RemoveHTML(icon,    maxWordLength, 1);
        name    = this.RemoveHTML(name,    maxWordLength, 1);
        game    = this.RemoveHTML(game,    maxWordLength, 1);
        message = this.RemoveHTML(message, maxWordLength, 1);
        
        // build key
        const key = game + `,${ icon },` + name;
        
        // find in trophy list
        const i = trophies.findIndex(e=>e[4]==key);
        
        // skip if same message
        if (i >=0 && trophies[i][3] == message) return;
        
        // add or update trophy list
        const trophyData = [game, name, icon, message, key];
        i < 0 ? trophies.unshift( trophyData ) :
            trophies[i] = trophyData;

        // save trophy
        localStorage['OS13kTrophy,' + key] = message;
        
        // reload trophy window
        trophyTrayIcon.program && trophyTrayIcon.program.Reload();
        
        // use game as name if there is no name
        name || game && (name = game, game = '');

        // add trophy popup
        this.Popup(
            `<div class=trophyIcon>${ 
                icon || 'üèÜ' }</div><div><b>${ // icon
                name }</b><br><i>${            // name
                game }</i></div>` +            // game
                message,                       // message
            name || game,                      // speak
            language);                         // language
            
        // save trophies
        OS13k.Save();
    }
    
    // get message, 0 if no trophy
    GetTrophy(game, name)
    {
        // find in trophy list
        const i = trophies.findIndex(e=>e[0]==game & e[1]==name);
        
        // return trophy message
        return i < 0 ? 0 : trophies[i][3];
    }
    
/////////////////////////////////////////////////////////////////////////////
// OS13k Audio

    // play zzfx sound from seed
    PlaySeed(seed, lengthScale=1, volume=1, randomness=.05, frequency)
    {
        // set random seed
        this.randomSeed = seed;
           
        // clamp max length
        lengthScale = this.Clamp(lengthScale, 0, 5);
     
        // helper functions
        const R=()=>this.Random(), C=()=>R()<.5?R():0, S=e=>C()?e:-e,
        
        // randomize sound length
        attack  = R()**3/4*lengthScale,
        decay   = R()**3/4*lengthScale,
        sustain = R()**3/4*lengthScale,
        release = R()**3/4*lengthScale,
        length  = attack + decay + sustain + release,
        f = R()**2*2e3;
        
        // generate random sound
        return zzfx
        (
           volume,           // volume
           randomness,       // randomness
           frequency || f,   // frequency
           attack,           // attack
           sustain,          // sustain
           release,          // release
           R()*5|0,          // shape
           R()**2*3,         // shapeCurve
           C()**3*S(99),     // slide
           C()**3*S(99),     // deltaSlide
           C()**2*S(1e3),    // pitchJump
           R()**2 * length,  // pitchJumpTime
           C() * length,     // repeatTime
           C()**4,           // noise
           C()**3*S(9),      // modulation
           C()**4,           // bitCrush
           C()**3/2,         // delay
           1 - C(),          // sustain volume
           decay             // decay
        );
    }
    
    // play raw audio sample data
    PlaySamples(samples, sampleRate=44100)
    {
        // create source and buffer
        const buffer = audioContext.createBuffer(1, samples.length, sampleRate)
        buffer.getChannelData(0).set(samples);

        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.connect(gain);
        source.start();
        return source;
    }
    
    // get frequency of a musical note on a diatonic scale
    Note(semitoneOffset=0, rootNoteFrequency=440)
    { return rootNoteFrequency * 2**(semitoneOffset/12); }

    // speak text
    Speak(text, rate=1, pitch=1, volume=1, language='en', stopSpeech)
    {
        // common languages (not supported in all browsers)
        // it - italian,  fr - french, de - german,  es - spanish, pl - polish
        // ja - japanese, hi - hindi,  ru - russian, zh - chinese, ko - korean
    
        // set utterance parameters
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.volume = volume * gain.gain.value * 3;
        utterance.pitch = pitch;
        utterance.rate = rate;
        utterance.lang = language;

        // stop speech if set
        stopSpeech && OS13kSystem.StopSpeech();

        // play speech if allowed
        settings[1] && finishedStartup && speechSynthesis && 
            speechSynthesis.speak(utterance);
    }
        
/////////////////////////////////////////////////////////////////////////////
// OS13k Shaders

    // create pixel shader
    CreateShader(canvas, code)
    {
        // get webgl context
        const x = canvas.getContext('webgl2');
        
        // use hardcoded values to save space
        const xVERTEX_SHADER       = 35633;
        const xARRAY_BUFFER        = 34962;
        const xSTATIC_DRAW         = 35044;
        const xBYTE                = 5120;
        const xFRAGMENT_SHADER     = 35632;
        const xCOMPILE_STATUS      = 35713;
        const xTEXTURE_2D          = 3553;
        const xUNPACK_FLIP_Y_WEBGL = 37440;
        const xTEXTURE_MIN_FILTER  = 10241;
        const xLINEAR              = 9729;

        // create a simple pass through vertex shader
        const vertexShader = x.createShader(xVERTEX_SHADER);
        x.shaderSource(vertexShader,
            '#version 300 es\n' +
            'in vec4 c;' +
            'void main()' +
            '{gl_Position=c;}');
        x.compileShader(vertexShader);
        
        // create vertex buffer that is a big triangle
        const vertexBuffer = xARRAY_BUFFER;
        x.bindBuffer(vertexBuffer, x.createBuffer());
        x.bufferData(vertexBuffer, new Int8Array([-3,1,1,-3,1,1]), xSTATIC_DRAW);
        x.enableVertexAttribArray(0);
        x.vertexAttribPointer(0, 2, xBYTE, 0, 0, 0); // 2D vertex
        
        // check vertex shader for errors
        //if (!x.getShaderParameter(vertexShader, x.COMPILE_STATUS))
        //    throw x.getShaderInfoLog(vertexShader);
        
        // create shadertoy compatible pixel shader
        const pixelShader = x.createShader(xFRAGMENT_SHADER);
        const shaderProgramCode = 
            '#version 300 es\n' +
            'precision mediump float;' +
            'uniform float iTime;' +
            'uniform int iFrame;' +
            'uniform vec4 iMouse;' +
            'uniform vec3 iResolution;' +
            'uniform sampler2D iChannel0;' +
            'out vec4 c;\n' +
            code +
            '\nvoid main()' +
            '{mainImage(c,gl_FragCoord.xy);' +
            'c.a=1.;}';
        x.shaderSource(pixelShader, shaderProgramCode);
        x.compileShader(pixelShader);

        // check pixel shader for errors OPTIONAL
        //if (!x.getShaderParameter(pixelShader, xCOMPILE_STATUS))
        //    throw x.getShaderInfoLog(pixelShader);

        // create texture
        x.bindTexture(xTEXTURE_2D, x.createTexture());
        x.texParameteri(xTEXTURE_2D, xTEXTURE_MIN_FILTER, xLINEAR);
        x.pixelStorei(xUNPACK_FLIP_Y_WEBGL, 1); 
        
        // create shader program
        const shaderProgram = x.createProgram();
        x.attachShader(shaderProgram, vertexShader);
        x.attachShader(shaderProgram, pixelShader);
        x.linkProgram(shaderProgram);
        x.useProgram(shaderProgram);
        return shaderProgram;
    }
    
    // render a pixel shader
    RenderShader(canvas, shaderProgram, time, frame, X, Y, Z, W)
    {
        // get webgl context
        const x = canvas.getContext('webgl2');
        
        // use hardcoded values to save space
        const xRGBA          = 6408;
        const xUNSIGNED_BYTE = 5121;
        const xTRIANGLE_FAN  = 6;
        const xTEXTURE_2D    = 3553;
        
        // set uniforms
        x.uniform3f(x.getUniformLocation(shaderProgram,'iResolution'), 
            canvas.width, canvas.height, 1);
        x.uniform1f(x.getUniformLocation(shaderProgram,'iTime'), time);
        x.uniform1f(x.getUniformLocation(shaderProgram,'iFrame'), frame);
        x.uniform1i(x.getUniformLocation(shaderProgram,'iChannel0'), 0);
        x.uniform4f(x.getUniformLocation(shaderProgram,'iMouse'), X, Y, Z, W);
        
        // render shader
        x.drawArrays(xTRIANGLE_FAN, 0, 3);
        
        // set texture to newly rendered image
        x.texImage2D(xTEXTURE_2D, 0, xRGBA, xRGBA, xUNSIGNED_BYTE, canvas);
    }

/////////////////////////////////////////////////////////////////////////////
// OS13k Input

    // get direction from wasd or arrow keys
    KeyDirection(keyCode)
    {
        let x=0, y=0;
        (keyCode == 87 | keyCode == 38) && ++y; // up
        (keyCode == 83 | keyCode == 40) && --y; // down
        (keyCode == 68 | keyCode == 39) && ++x; // right
        (keyCode == 65 | keyCode == 37) && --x; // left
        return {x, y};
    }
    
/////////////////////////////////////////////////////////////////////////////
// OS13k Text
    
    // remove html tags from a string
    RemoveHTML(string, maxLength)
    {
        // convert to string
        return (string+='')
        
            // clamp max length
            .substring(0, maxLength? maxLength: string.length)
            
            // replace tags
            .replace(/<.*>/g,'');
    }
    
    Popup(html, speak, language)
    {
        // create popup
        const popup = popups.appendChild(document.createElement('div'));
        popup.className = 'popup';
        popup.innerHTML = html;
        popup.speak = speak;
        popup.speakLanguage = language;
        popup.style.visibility = 'hidden';
    }
    
/////////////////////////////////////////////////////////////////////////////
// OS13k Seralization
    
    Save()
    {   
        // save data if finished startup
        finishedStartup && (
        localStorage.OS13k = JSON.stringify(
        {
            t:trophies,
            s:settings,
            i:programInfos,
            p:startProgramName = startProgram ? startProgram.name : ''
        }));
        
        // set gain and stop all speech if muted
        (gain.gain.value = settings[0]) || 
            OS13kSystem.StopSpeech(OS13k.Trophy('OS13k','üîá','Shut Up!','Muted'))
           
        // speech
        settings[1] || OS13kSystem.StopSpeech();
        
        // background
        background.style.background = 
            `linear-gradient(${settings[4]},${settings[5]})`;
        background.innerText = settings[6];
        
        // popups
        settings[2] || (popups.innerHTML = '');
        
        // filter
        background.style.filter = 
        desktop.style.filter = settings[7];
    }
    
    Load()
    {
        // use defaults if no settings found
        if (!localStorage.OS13k) return;
    
        // load data
        const saveData   = JSON.parse(localStorage.OS13k);
        trophies         = saveData.t;
        settings         = saveData.s;
        programInfos     = saveData.i;
        startProgramName = saveData.p;
    }
    
    Settings() { return settings; }
    
    SaveSettings(volume, speech, showPopups, systemSounds, 
        color1, color2, text, filter)
    {
        // set settings and save
        this.Save(
            settings = 
            [
                gain.gain.value = volume,
                speech,
                showPopups,
                systemSounds,
                color1,
                color2,
                text,
                filter
            ]);
    }
    
}; // _OS13k
var OS13k = new _OS13k;

///////////////////////////////////////////////////////////////////////////////
// OS13k Variables

const taskbarHeight = 44, titlebarHeight = 37, programHeight = 26,
      startOpenOffset = 9, popupTime = 3, defaultVolume = .3, maxWordLength = 32,

    // system sounds
    soundOpen       = -8,
    soundClose      = 92,
    soundGrabStart  = 45,
    soundGrabEnd    = 42,
    soundMenu       = 8,
    soundTrophy     = 96,
    soundActive     = 87,
    soundShrink     = 75,
    soundGrow       = 61,
    soundFullScreen = -9,
    soundHelp       = 48,
    soundCode       = 16,
    soundReload     = 85,
    soundProgram    = 90,

    // init web audio
    audioContext = new AudioContext, gain = audioContext.createGain();

let grabWindow, grabOffsetX, grabOffsetY, finishedStartup,
    activeWindow, activeProgram, activeTaskbarIcon, loadIcon,
    lastActiveElement, topZ = 0, loading = 0, hadInput = 0,
    windowOpenX = startOpenOffset, windowOpenY = startOpenOffset + taskbarHeight,
    startProgram, startProgramName, programInfos = [], trophies = [],
    trophyTrayIcon, settingsTrayIcon, clockTrayIcon,

    // default settings (volume, speech, popups, color1, color2, text, filter)
    settings = [.3, 1, 1, 1, '#222233', '#332222', 'OS13k', ''];

///////////////////////////////////////////////////////////////////////////////
// OS13k System Functions - handles non client facing features of OS13k

class _OS13kSystem
{
    Start()
    {
        // create tray icons
        trophyTrayIcon    = new OS13kTrayIcon();
        settingsTrayIcon  = new OS13kTrayIcon();
        clockTrayIcon     = new OS13kTrayIcon();
        
        // load os13k data and connect gain
        OS13k.Save(OS13k.Load(gain.connect(audioContext.destination)));
    
        // listen for trophies from other windows
        window.onstorage=e=> this.CheckForTrophy(e.key);

        // stop spech if page is unloaded
        desktop.onunload = OS13kSystem.StopSpeech();

        // set button functions
        buttonFullScreen.onmousedown =()=> activeWindow.FullScreen();
        buttonHelp.onmousedown       =
        buttonCode.onmousedown       =()=> activeWindow.ShowCode();
        buttonResetSize.onmousedown  =()=> activeWindow.Resize(1, soundGrow);
        buttonReload.onmousedown     =()=> activeWindow.Reload();
        buttonClose.onmousedown      =()=> activeWindow.Close();

        // create load program taskbar icon and add folders/programs
        loadIcon = new OS13kTaskbarIcon( {icon:'üíæ', name:'Load Program'} );
        loadIcon.windowOrMenu = new OS13kProgramMenu(programs);
        
        // welcome message
        OS13k.Trophy('','üëã','Welcome to OS13k!');

        // search local storage for new trophies (from other JS13k games)
        for (const key in localStorage) this.CheckForTrophy(key);

        // try to update startup and kick off first update
        this.Update(this.UpdateStartup());
    }

    // wait for startup to finish
    UpdateStartup()
    {
        // skip until not loading and finished startup
        if ((loading&&--loading) | finishedStartup) return;
            
        // open start program (check top to stop infinite recursion if meta)
        startProgram && self == top | startProgram.sticky && startProgram.Open();
            
        // finish startup after opening startup programs
        finishedStartup = 1;
        
        // save os13k data
        OS13k.Save();
    }

    // main update loop
    Update()
    {
        // request new animation frame
        requestAnimationFrame(OS13kSystem.Update);
            
        // check if iframe became new active element
        const activeElement = document.activeElement;
        if (lastActiveElement != activeElement)
        {
             // set active element and set that we had input
            activeElement.SetActive && activeElement.SetActive(hadInput = 1);
            lastActiveElement = activeElement;
        }

        // fade in desktop, convert opacity to number
        loading || (document.body.style.opacity 
            = Math.min(1,.02 + document.body.style.opacity*1));

        // update trophy count
        trophyTrayIcon.innerHTML = trophies.length + ' üèÜ';

        // update time
        clockTrayIcon.title = new Date();
        const time = clockTrayIcon.title.slice(16,24).split(':');
        clockTrayIcon.innerHTML = (time[0]%12?time[0]%12:12) + ':' + time[1];

        // show popups after startup is finished and there was input
        if (!finishedStartup || !hadInput) return;
        
        // update popups, use copy to prevent skipping if removed
        let offsetY = 0;
        [...popups.children].map((popup,i)=>
        {
            // popup sounds
            popup.speak && OS13k.Speak(popup.speak, 1, 1, 1, popup.speakLanguage);
            popup.speak = 0;
            
            if (!settings[5])
                popups.removeChild(popup);
            else if (!document.fullscreenElement)
            {
                // move popup up, set to bottom if it was invisible
                let y = popup.style.visibility ? 
                     innerHeight : parseFloat(popup.style.top) + offsetY - 9;
                popup.style.visibility = '';
                
                if (y < taskbarHeight)
                {
                    // stop popup below taskbar
                    y = taskbarHeight;

                    // fade out popup if at top
                    if (!i && !(popup.style.opacity = (popup.style.opacity || popupTime) - .01))
                    {
                        // remove when invisible and adjust for height
                        const rect = popup.getBoundingClientRect();
                        offsetY += rect.height;
                        popups.removeChild(popup);
                    }
                }

                // set popup position
                popup.style.top = y;
            }});
    }

    // close all menus
    CloseMenus()
    {
        // hide all menus
        [...programsMenu.children].map(child=>
            child.style.visibility = menu.style.visibility = '');
            
        // unselect active program
        activeProgram && (activeProgram.className = 'program');
    }

    // try to give trophy if key is valid
    CheckForTrophy(key)
    {
        const keyParts = key.split(',');
        return keyParts.shift() == 'OS13kTrophy' &&
            OS13k.Trophy(...keyParts, localStorage[key]);
    }
    
    // stop any current or queued speech
    StopSpeech() { speechSynthesis && speechSynthesis.cancel(); }
    
    // play system sound if enabled
    Sound(seed, length) 
    { hadInput && settings[3] && OS13k.PlaySeed(seed, length); }
    
} // OS13kSystem
const OS13kSystem = new _OS13kSystem;

///////////////////////////////////////////////////////////////////////////////
// OS13kProgramMenu - holds a list of programs

class OS13kProgramMenu extends HTMLElement
{
	constructor(infos, y=0, parentMenu)
    {
		super();
        
        // add to programs menu
        this.className    = 'programMenu';
        this.style.left   = parentMenu && parentMenu.getBoundingClientRect().right - 2;
        this.style.top    = y;
        this.parentMenu   = parentMenu;
        programsMenu.appendChild(this);
        
        // add programs to menu
        infos.map(info=>
        {
            // create program and add it to menu
            const folder = info[7];
            this.appendChild(new OS13kProgram(folder ? 
                new OS13kProgramMenu(folder, y, this) : this, ...info));
                
            // add program height as we move down list
            y += programHeight;
        });
    }

    SetActive()
    {
        
        // close menus so they can reopen with this active
        OS13kSystem.CloseMenus();
        
        // set parent active
        this.parentMenu && this.parentMenu.SetActive();
        
        // make visible
        this.style.visibility = 'visible';
    }
} // OS13kProgramMenu
customElements.define('m-', OS13kProgramMenu);

///////////////////////////////////////////////////////////////////////////////
// OS13kProgram - stores program info and handles loading from folders
    
class OS13kProgram extends HTMLElement
{
	constructor(programMenu, src='', icon='üí†', width=defaultWidth, height=defaultHeight, flags, name='', help='', folder)
    {
		super();
        
        // split source by . to get extension
        const srcParts = src.split('.');
        
        // split source by / to get filename to convert camel case src OPTIONAL
        let srcCleanName = srcParts[0].split('/');

        // add spaces between lower case and capitals
        srcCleanName = srcCleanName[srcCleanName.length-1]
            .replace(/([a-z](?=[A-Z]))/g, '$1 ');
            
        // make first letter uppercase and set if no name
        name = name || (srcCleanName[0].toUpperCase() + srcCleanName.slice(1));
        
        // check for special extensions
        const extension = src ? srcParts[1] : '';
        this.isDweet = extension == 'dweet';
        this.isShader = extension == 'shader';

        // set icon data
        this.className = 'program';
        this.src    = src;
        this.icon   = icon;
        this.width  = width;
        this.height = height;
        this.name   = name;
        this.folder = folder;   
        this.key    = 'OS13kP' + src;
        this.programMenu = programMenu;
        
        // set code only if help not shown or if has extension and not disabled
        this.code = !(this.help = help) && 
            (flags & code || ((this.isDweet || this.isShader) && flags == undefined));
            
        // set flags
        flags = flags || defaultFlags;
        this.sticky   = flags & sticky;
        this.reload   = flags & reload;
        this.awake    = flags & awake;
        this.full     = flags & full;
        this.resize   = flags & resize;
        
        // load saved program data and set title if not a folder
        this.LoadInfo(folder || (this.title = name));
        
        // create div for icon to auto close html tags
        const iconDisplay = this.appendChild(document.createElement('div'));
        iconDisplay.style = 'pointer-events:none;width:45;text-shadow:1px 1px 3px #000;text-align:center';
        iconDisplay.innerHTML = icon;
        
        // name and folder
        this.innerHTML += `<div style=flex:1;padding-right:9;pointer-events:none>${
            name }</div>` + (folder? '‚ñ∂' : '');
        
        // save special programs
        name == 'Settings'    && settingsTrayIcon.SetProgram(this);
        name == 'Trophy Case' && trophyTrayIcon.SetProgram(this);
        name == 'Clock'       && clockTrayIcon.SetProgram(this);
        
        // open help if it has not been opened yet
        name == 'Help'        && 
            this.info.open == undefined && (startProgram = this);
        
        // check if start program or sticky open
        this.sticky ? this.info.open && this.Open() :
            this.name == startProgramName && (startProgram = this); 
    }
    
    Move()
    {
        // set container program menu active 
        this.programMenu.SetActive();
        
        activeProgram !=this && OS13kSystem.Sound(soundProgram, 0);
        
        // set active
        activeProgram = this;
        this.className = 'program programActive';
    }
    
    Open()
    {
        if (this.window)
        {        
            // set window to be active and clamp
            this.window.SetActive(1, 1);
            
            // prevent main document focus
            return false;
        }
        if (this.src)
        {
            // get saved window position
            let x = this.info.x, y = this.info.y;
            
            // update window open positions if no position was set
            x || (
                x = windowOpenX,
                y = windowOpenY,
                (windowOpenX += titlebarHeight) > 400 && (windowOpenX =  windowOpenY = startOpenOffset),
                (windowOpenY += titlebarHeight) > 200 && (windowOpenY =  windowOpenY = startOpenOffset + taskbarHeight));

            // open window
            this.window = new OS13kWindow(this, x, y);

            // update info and save
            this.SaveInfo();
        }
        else if (!this.folder)
        {
            // close all windows if no src or folder
            [...desktop.children].map(child=> child.Close && child.Close());

            // reset window open position
            windowOpenX = startOpenOffset;
            windowOpenY = startOpenOffset + taskbarHeight;

            OS13k.Trophy('OS13k','‚òï','Coffee Is For Closers','Closed All');
        }
    }
    
    SetActive() { this.Open(); }
    
    // call reload function in iframe if it exists
    Reload()
    {
        this.window && this.window.iframeContent &&
            this.window.iframeContent.OS13kReload &&
            this.window.iframeContent.OS13kReload();
    }
    
    // toggle program open or closed
    Toggle()
    {
        activeWindow && activeWindow == this.window ?
            this.window.Close() : this.Open();
    }
    
    // load saved program info from local storage
    LoadInfo() 
    {
        // find in program info list
        const i = programInfos.findIndex(e=>e.name==this.name);
        this.info = i < 0 ? {} : programInfos[i];
    }
   
    // save program info and reset settings when closed if non sticky
    SaveInfo(open = 1)
    {
        // build save info
        this.info = 
        {
            name: this.name,
            open,
            x: open | this.sticky ? this.window.style.left : 0,
            y: this.window.style.top,
            scale: open | this.sticky ? this.window.scale : 1
        }
        
        // add to programs info and save
        const i = programInfos.findIndex(e=>e.name==this.name);
        OS13k.Save(i < 0 ? programInfos.push(this.info) 
            : programInfos[i] = this.info);
    }
    
} // OS13kProgram
customElements.define('p-', OS13kProgram);

///////////////////////////////////////////////////////////////////////////////
// OS13kWindow - window to a running program, handles program loading

class OS13kWindow extends HTMLElement
{
	constructor(program, x, y)
    {
		super();

        // add to desktop
        desktop.appendChild(this);
        
        // save settings
        this.program = program;
        this.style.left = x;
        this.style.top = y;
        this.menu = 1;
        this.activeCount = 0;
        
        // shadow root
		this.attachShadow({mode: 'open'});
        this.shadowRoot.innerHTML = T.innerHTML;
        
        // title bar
        this.titlebar = this.shadowRoot.appendChild(document.createElement('div'));
        this.titlebar.id = 'titlebar';
        this.titlebar.title = program.title;
        
        // title bar name
        this.name = this.titlebar.appendChild(document.createElement('div'));
        this.name.id = 'name';
        
        // create div for icon to auto close html tags
        const icon = this.name.appendChild(document.createElement('div'));
        icon.id = 'icon';
        icon.innerHTML = program.icon;

        // name
        this.name.innerHTML += program.name;
       
        // create title bar icons
        const AddTitlebarIcon=(id, title, svg, shape='path')=>
        {
            const icon = this.titlebar.appendChild(document.createElement('div'));
            icon.id = id;
            icon.title = title;
            icon.innerHTML = 
            `<svg style=height:100%;width:28;pointer-events:none viewBox='0 0 10 10'><${shape} stroke=#000 fill=none ${svg} />`;
        }
        program.resize && 
            AddTitlebarIcon('grow', 'Grow', 'd="M2 5L8 5M5 8L5 2"',
            AddTitlebarIcon('shrink', 'Shrink', 'd="M2 5L8 5"'));
        program.full && AddTitlebarIcon(
            'full', 'Full Screen', 'x=1 y=2 width=8 height=6', 'rect');
        program.help && AddTitlebarIcon('help', 'Help', 'd="M5 8L8 2L2 2L5 8L8 2"');
        program.code && AddTitlebarIcon('code', 'Code', 'd="M5 2L8 8L2 8L5 2L8 8"');
        program.reload && AddTitlebarIcon(
            'reload', 'Reload', 'cx=5 cy=5 r=3', 'circle');
        AddTitlebarIcon('close', 'Close', 'd="M2 2L8 8M8 2L2 8"');

        // create content wrapper
        (this.iframeWrapper =
            this.shadowRoot.appendChild(document.createElement('div')))
            .style.background = '#000';

        // create code/help display
        (this.codeDisplay =
            this.shadowRoot.appendChild(document.createElement('textarea')))
            .id = 'codeDisplay';
        this.codeDisplay.setAttribute('readOnly', 1);
        
        // resize window size to fit inner width while preserving aspect
        const width = program.resize ? 
            Math.min(program.width*(this.program.info.scale||1), innerWidth-6) :
            program.width;
            
        // set window width, height, and scale
        this.titlebar.style.width      = 
        this.iframeWrapper.style.width  = width;
        this.iframeWrapper.style.height = width * program.height / program.width;
        this.scale = width / program.width;

        // create iframe
        this.iframe = this.iframeWrapper.appendChild(document.createElement('iframe')); 
        this.iframe.id = 'frame';
        
        // announce game when first opened
        OS13k.Speak(this.program.name);
        
        // track if programs are loading during startup
        loading += !finishedStartup;
        
        // wait for frame to load
        this.iframe.onload =e=>
        {
            // set this to be the active element
            lastActiveElement = this;
            
            // check for special extensions
            const hasExtension = program.isDweet || program.isShader;

            // get iframe content (will fail if cross site)       
            const iframeContent = this.iframeContent = e.target.contentWindow;

            // get document (will fail if cross site)
            const iframeDocument = iframeContent.document;
            
            // get document text
            const iframeText = iframeDocument.body
                [hasExtension ? 'innerText' : 'innerHTML'];

            // set help/code display
            this.codeDisplay.value = program.help || iframeText;

            // pass OS13k to iframe
            iframeContent.OS13k = OS13k;
            
            // pass zzfx to iframe
            iframeContent.zzfx = zzfx;

            // prevent iframes context menu
            iframeContent.oncontextmenu =()=> false;

            // check for extensions
            if (hasExtension) 
            {
                // create full size canvas
                iframeDocument.body.innerHTML = 
                    `<canvas id=c width=1920 height=1080 style=` +
                    'width:100%;background:#' +
                    (program.isDweet ? 'fff' : '000') +'>';
                
                // set body style
                iframeDocument.body.style = 
                    'background:#111;' +
                    'overflow:hidden;' +
                    'margin:0;' +
                    'display:flex;' +
                    'align-items:center';

                // create dweet
                program.isDweet && iframeContent.eval(
                    'u=t=>{' + iframeText + '};' +
                    'x=c.getContext`2d`;' +
                    'S=Math.sin;' +
                    'C=Math.cos;' +
                    'T=Math.tan;' +
                    'R=(r,g,b,a=1)=>`rgba(${0|r},${0|g},${0|b},${a})`;' + 
                    'loop=t=>requestAnimationFrame(loop,' +
                    (program.awake? '' : 't<1e3|document.hasFocus()&&') +
                        'u((60*(frame++/60)-frame-1|0?frame-1:frame)/60));' +
                    'loop(frame=0)');

                // create shader
                program.isShader && iframeContent.eval(
                    'x=c.getContext`webgl2`;' +
                    'onmousemove=e=>e.buttons&&(X=e.x,Y=c.height-e.y);' +
                    'onmousedown=e=>(X=Z=e.x,Y=W=c.height-e.y);' +
                    'onmouseup=e=>Z=W=0;' +
                    's=parent.OS13k.CreateShader(c,`' + iframeText + '`);' + 
                    'loop=t=>requestAnimationFrame(loop,' +
                    (program.awake? '' : 't<1e3|document.hasFocus()&&') +
                        '(c.width=innerWidth,' + 
                        'c.height=innerHeight,' + 
                        'parent.OS13k.RenderShader(c,s,f/60,f++,X,Y,Z,W)));' + 
                    'loop(X=Y=Z=W=f=0)');
            }

            // add taskbar icon if it doesnt exist (from being reloaded)
            this.taskbarIcon ||
                (this.taskbarIcon = new OS13kTaskbarIcon(program, this));

            // make visible
            this.style.visibility = this.iframe.style.visibility = 'visible';
            
            //set active if not grabbing and update startup routine
            OS13kSystem.UpdateStartup(grabWindow || this.SetActive());
        }
        
        // load src, force pages to be refreshed OPTIONAL
        this.iframe.src = program.src + '?2050';
    }
    
    Open(target, x, y)
    {
        // set grab window if name is target
        if (target == this.name)
        {
            // set this to be grab window and set active
            this.SetActive(grabWindow = this);
            
            // use grabbing cursor
            background.style.cursor = taskbar.style.cursor = 'grabbing';
            
            // prevent anything from getting focus white grabbing
            desktop.style.pointerEvents = 'none';

            // save grab offset
            const rect = this.getBoundingClientRect();
            grabOffsetX = x - rect.left;
            grabOffsetY = y - rect.top;
            
            OS13kSystem.Sound(soundGrabStart)
            
            // allow main document focus
            return;
        }
        
        // set active
        this.SetActive();
        
        // check for title bar buttons
        target.id == 'full'        && this.FullScreen();
        target.id == 'reload'      && this.Reload();
        target.id == 'close'       && this.Close();
        target.id == 'shrink'      && this.Resize(this.scale - .2, soundShrink );
        target.id == 'grow'        && this.Resize(this.scale + .2, soundGrow );
        (target.id == 'help' | target.id == 'code') && this.ShowCode();
        
        // allow main document focus if code display or grabbing
        return target == this.codeDisplay || grabWindow == this;
    }
    
    Resize(scale, sound)
    {
        sound && OS13kSystem.Sound(sound);
    
        // change size of window while preserving aspect
        const wNew = OS13k.Clamp(this.program.width * scale, 300, 1920);
        const hNew = this.program.height * (this.scale = wNew / this.program.width);
        
        // get old width
        const w = parseFloat(this.iframeWrapper.style.width);
        
        // offset window position for new width
        this.style.left = parseFloat(this.style.left) + w - wNew;
        
        // set new size
        this.titlebar.style.width = this.iframeWrapper.style.width = wNew;
        this.iframeWrapper.style.height = hNew;
    
        // update program info
        this.program.SaveInfo();
    }
    
    SetActive(active=1, clamp)
    {
        // close menus when window is set active
        OS13kSystem.CloseMenus();
        
        // set style, dim non active windows
        this.className = active? 'activeWindow' : '';
        this.titlebar.className = 'titlebar ' 
            + (active && !loading? 'titlebarActive' : this.program.sticky ? 'titlebarSticky' : '');
        this.iframeWrapper.style.filter = active || this.program.awake ? 
            '' : 'saturate(.7)brightness(.7';

        // check if active
        if (!active) return;
        
        // save start program if finished startup and not sticky
        finishedStartup && !this.program.sticky && 
            OS13k.Save(startProgram = this.program);

        // set focus to iframe if not loading
        loading || this.iframeContent && this.iframeContent.focus();

        // clamp window to screen
        const rect = this.getBoundingClientRect();
        clamp && (
            this.style.left = OS13k.Clamp(rect.x, 0, innerWidth - rect.width,
            this.style.top = OS13k.Clamp(rect.y, taskbarHeight, 
                Math.max(taskbarHeight, innerHeight - rect.height))));

        if (activeWindow != this)
        {
            // deactivate old window
            activeWindow && activeWindow.SetActive(0);
            
            // set this to be active window
            activeWindow = this;

            // move z to top
            this.style.zIndex = ++topZ;

            // show menu buttons
            const SetButtonVisibility=(button, visible)=>
                button.style.display = visible ? '' : 'none';
            SetButtonVisibility(buttonFullScreen, this.program.full);
            SetButtonVisibility(buttonCode,       this.program.code);
            SetButtonVisibility(buttonHelp,       this.program.help);
            SetButtonVisibility(buttonReload,     this.program.reload);
            SetButtonVisibility(buttonResetSize,  this.program.resize);

            // set taskbar icon active if it exists
            // it will not have been created yet if frame is loading
            this.taskbarIcon && this.taskbarIcon.SetActive();
            
            !grabWindow &&hadInput && 
                OS13kSystem.Sound(this.activeCount ? soundActive : soundOpen);
            this.activeCount++;
        }
        
        return false;
    }
    
    FullScreen()
    {
        // check if full screen allowed
        if (!this.program.full) return;
        
        // set full screen
        this.iframeWrapper.webkitRequestFullScreen &&
            this.iframeWrapper.webkitRequestFullScreen();
        this.iframeWrapper.mozRequestFullScreen &&
            this.iframeWrapper.mozRequestFullScreen();
            
        OS13kSystem.Sound(soundFullScreen);
        OS13k.Trophy('OS13k','üïπÔ∏è','Pro Gamer','Went Full Screen');
    }
    
    ShowCode()
    {
        // toggle showing code
        this.codeDisplay.style.display = 
            (this.showCode = !this.showCode) ? 'inline' : '';
        
        OS13kSystem.Sound(this.program.help ? soundHelp : soundCode);
        this.program.help || OS13k.Trophy('OS13k','üë®‚Äçüíª','Hacker','Viewed Code');
    }
    
    Reload()
    {
        // reload program or reload iframe and set invisible
        this.program.Reload() || 
            this.iframeContent.location.reload(this.iframe.style.visibility = '');
        
        OS13kSystem.Sound(soundReload);
    }
    
    Close()
    {
        // remove start program if closed
        this.program.name == startProgramName && OS13k.Save(startProgram = 0);
            
        // save info and set closed
        this.program.SaveInfo(0);
        
        // invalidate window after info is saved
        this.program.window = 0;
        
        // remove taskbar icon and self
        this.taskbarIcon.remove();
        this.remove();
        
        OS13kSystem.Sound(soundClose);
    }
} // OS13kWindow
customElements.define('w-', OS13kWindow);

///////////////////////////////////////////////////////////////////////////////
// OS13kTaskbarIcon - icon on taskbar that can be used as shortcut

class OS13kTaskbarIcon extends HTMLElement
{
	constructor(program, windowOrMenu)
    {
		super();
        
        // create icon
        this.className = 'taskbarIcon';
        this.innerHTML = '<div style=pointer-events:none>' + program.icon;
        this.title = program.title || program.name;
        
        // save window, only a menu if load icon
        this.windowOrMenu = this.menu = windowOrMenu;
        
        // add to taskbar
        taskbarSpace.before(this);
    }
    
    Open()
    {
        // set active
        this.SetActive();
        
        // allow main document focus only if load icon
        this == loadIcon;
    }
    
    SetActive(active=1)
    {
        // set window active and clamp
        active && this.windowOrMenu.SetActive(1, 1);
    
        // load icon cant be active taskbar item
        if (this == loadIcon) 
        { OS13kSystem.Sound(soundMenu, .5); return;}
        
        // set active style
        this.className = 'taskbarIcon ' + (active ? 'taskbarIconActive' : '');
        
        // check if active
        if (!active) return;
            
        // unselect old taskbar icon
        activeTaskbarIcon && activeTaskbarIcon != this &&
            activeTaskbarIcon.SetActive(0);

        // set this to be active taskbar icon
        activeTaskbarIcon = this;
    }
    
} // OS13kTaskbarIcon
customElements.define('i-', OS13kTaskbarIcon);

///////////////////////////////////////////////////////////////////////////////
// OS13kTrayIcon - icon on taskbar tray for OS shortcuts

class OS13kTrayIcon extends HTMLElement
{
	constructor()
    {
		super();
        
        // create tray icon and add it
        this.className = 'trayIcon';
        tray.appendChild(this);
    }
    
    SetProgram(program)
    {
        // set program, title, and icon
        this.program = program;
        this.title = program.title;
        this.innerHTML = program.icon;
    }
    
    Open() { this.program ? this.program.Toggle() : this.functionCall(); }
} // OS13kTrayIcon
customElements.define('t-', OS13kTrayIcon);

///////////////////////////////////////////////////////////////////////////////
// Mouse Input

{
onmousedown=e=>
{
    // set there has been user input
    hadInput = 1;
    
    // check if load icon is target while programs menu was visible
    if (e.target == loadIcon && e.target.windowOrMenu.style.visibility)
    {
        // close menus because they were open
        OS13kSystem.CloseMenus();
        
        // reactivate active window
        activeWindow && activeWindow.SetActive();
        
        // prevent main document from taking focus
        return false;
    }
    
    // close menus on mouse down
    OS13kSystem.CloseMenus();

    // reset program menu position
    programsMenu.style.left = 0;
    programsMenu.style.top = taskbarHeight;

    // prevent stuck grab (from tabbing to another window while grabbing)
    if (grabWindow) return onmouseup(e);
    
    // get orignal target
    const originalTarget = e.originalTarget || e.path[0];
    
    // check if not left mouse button
    if (e.button)
    {
        // check for right mouse button
        if (e.button & 2)
        {
            const target = e.target.window || e.target;

            // don't do anything if code or button
            if (originalTarget.id != 'codeDisplay' & e.target.localName != 'button')
            {
                // set target active, use load icon if no valid target
                (target.SetActive ? target : loadIcon).SetActive();

                // get which menu to open
                const targetMenu = e.target.menu 
                    ? (OS13kSystem.Sound(soundMenu, .5), menu) : programsMenu;

                // show context menu
                targetMenu.style.left = e.x;
                targetMenu.style.top  = e.y;
                targetMenu.style.visibility = 'visible';
            }
        }
    
        // allow main document to take focus
        return;
    }

    // open window or reactivate if no valid target
    return e.target.Open ? e.target.Open(originalTarget, e.x, e.y) :
        activeWindow && activeWindow.SetActive();
}

onmousemove=e=>
{
    grabWindow &&
    (
        // update grab position
        grabWindow.style.left = e.x - grabOffsetX,
        grabWindow.style.top = e.y - grabOffsetY,
        
        // save info
        grabWindow.program.SaveInfo()
    );
    
    // handle mouse move
    e.target.Move && e.target.Move();
}

onmouseup=e=>
    // set grab window active, no clamp, and set cursor to default, unset grab
    grabWindow && (OS13kSystem.Sound(soundGrabEnd),
    grabWindow.SetActive(1, 0),
        background.style.cursor = taskbar.style.cursor
            = desktop.style.pointerEvents = grabWindow = '');

// prevent default right click context menu
oncontextmenu=e=>false;

} // mouse input

///////////////////////////////////////////////////////////////////////////////
// ZzFXMicro - Zuper Zmall Zound Zynth
var zzfx=(...t)=>OS13k.PlaySamples(zzfxG(...t)),

zzfxG = // generate zzfx samples
(volume = 1, randomness = .05, frequency = 220, attack = 0, sustain = 0, release = .1, shape = 0, shapeCurve = 1, slide = 0, deltaSlide = 0, pitchJump = 0, pitchJumpTime = 0, repeatTime = 0, noise = 0, modulation = 0, bitCrush = 0, delay = 0, sustainVolume = 1, decay = 0, sampleRate = 44100, b = [])=>
{
    attack = 99 + attack * sampleRate;
    sustain *= sampleRate;
    release *= sampleRate;
    decay *= sampleRate;
    delay *= sampleRate;
    
    for(
        // init parameters and helper functions
        let PI2 = Math.PI*2,
        random =r=> 1 + r*2*Math.random() - r,
        sign =v=> v>0? 1 : -1,
        length = attack + decay + sustain + release + delay,
        startSlide = slide *= 500 * PI2 / sampleRate**2,
        startFrequency = frequency *= random(randomness) * PI2 / sampleRate,
        modPhase = sign(modulation) * PI2/4,
        t=0, tm=0, i=0, j=1, r=0, c=0, s=0;
    
        // loop and generate waveform
        i < length; b[i++] = s)
    {
        if (++c>bitCrush*100)                            // bit crush
        {
            c = 0;                                       // reset bit crush
            s = t * frequency *                          // frequency
                Math.sin(tm * modulation * PI2 / sampleRate - modPhase); // modulation

            s = shape? shape>1? shape>2? shape>3?        // wave shape
                Math.sin((s%PI2)**3) :                   // 4 noise
                Math.max(Math.min(Math.tan(s), 1), -1):  // 3 tan
                1-(2*s/PI2%2+2)%2:                       // 2 saw
                1-4*Math.abs(Math.round(s/PI2)-s/PI2):   // 1 triangle
                Math.sin(s);                             // 0 sin
            s = sign(s)*(Math.abs(s)**shapeCurve);       // curve 0=square, 2=pointy

            s *= volume * (                              // envelope
                i < attack ? i/attack :                  // attack
                i < attack + decay ?                     // decay
                1-((i-attack)/decay)*(1-sustainVolume) : // decay falloff
                i < attack + decay + sustain ?           // sustain
                sustainVolume :                          // sustain volume
                i < length - delay ?                     // release
                (length - i - delay)/release *           // release falloff
                sustainVolume :                          // release volume
                0);                                      // post release

            s = delay ?                                  // delay
                s/2 + (delay > i ? 0 :
                (i<length-delay? 1 : (i-length)/delay) * // release delay 
                b[i - delay|0]/2) : s;                   // sample delay
        }

        t += random(noise);                          // noise
        tm += random(noise);                         // modulation noise
        frequency += slide += deltaSlide             // frequency slide
            * 500 * PI2 / sampleRate**3;             // apply sample rate

        if (j && ++j > pitchJumpTime * sampleRate)   // pitch jump
        {
            frequency += pitchJump                   // apply pitch jump
                * PI2 / sampleRate;                  // apply sample rate
            startFrequency += pitchJump              // also apply to start
                * PI2 / sampleRate;                  // apply sample rate
            j = 0;                                   // reset pitch jump time
        }

        if (repeatTime && ++r > repeatTime* sampleRate) // repeat
        {
            frequency = startFrequency;               // reset frequency
            slide = startSlide;                       // reset slide
            r = 1;                                    // reset repeat time
            j = j || 1;                               // reset pitch jump time
        }
    }
    
    return b;
}

///////////////////////////////////////////////////////////////////////////////
// Start OS13k!

OS13kSystem.Start();

///////////////////////////////////////////////////////////////////////////////
// Mobile Support OPTIONAL

// save if user was touching
let wasTouching;
    
if (typeof ontouchstart != 'undefined')
{
    // remove hovers, they get stuck on mobile
    const RemoveHovers=e=>
    {
        [...e.styleSheets].map(sheet=>{
        for(let i = sheet.rules.length; i--; )
            sheet.rules[i].selectorText &&
            sheet.rules[i].selectorText.match('hover') &&
            sheet.deleteRule(i)});
    }
    RemoveHovers(document);
                
    // handle touch event
    const ProcessTouch=e=>
    {
        // check if touching
        const touching = e.touches.length;
        if (touching)
        {
            // set event pos
            e.x = e.touches[0].clientX;
            e.y = e.touches[0].clientY;

            // pass event to mousemove and give focus to main window
            window.focus(onmousemove(e));
        }

        // pass event to mouse down, prevent closing folders
        touching & !wasTouching & !e.target.folder && onmousedown(e);

        // pass event to mouse up
        !touching & wasTouching && onmouseup(e);

        // set was touching
        wasTouching = touching;
        
        // remove hovers from active window
        activeWindow && RemoveHovers(activeWindow.shadowRoot);
        
        // prevent default if possible
        return !e.cancelable;
    }
    
    // set touch events
    ontouchstart = ontouchmove = ontouchend = ontouchcancel = ProcessTouch;
};

</script>
