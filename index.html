<head>
<title>OS13k - A tiny pseudo operating system for JS13k</title>
<meta charset=utf-8>
<meta name=viewport content='width=device-width,initial-scale=1,user-scalable=0'>
<link rel=icon type=image/x-icon href='favicon.png?1'/>
<style>
*
{
    user-select:none;
    font-family:arial;
}
body
{
    margin:0;
    background:linear-gradient(#223,#322);
    overflow:hidden;
    touch-action:none;
}
.taskbar
{
    height:44;
    width:100%;
    z-index:10000;
    background:linear-gradient(#999,#444);
    border:2px solid;
    display:flex;
    align-items:center;
    position:absolute;
}
.icon
{
    margin:2;
    width:44;
    height:35;
    font-size:22;
    border-radius:9px;
    box-shadow:0px 0px 3px;
    text-shadow:1px 1px 2px #000;
    background:linear-gradient(#fff,#333);
    border:2px solid;
    display:flex;
    align-items:center;
    justify-content:center;
}
.title
{
    height:100%;
    color:#0002;
    font-family:impact;
    font-weight:900;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:none;
}
.selected       { background:linear-gradient(#ff8,#fff); }
.icon:hover     { background:linear-gradient(#fff,#44f); }
.selected:hover { background:linear-gradient(#ff8,#44f); }
</style>
<template id=templateIcon>
<style>
:host
{
    display:flex;
    align-items:center;
    flex-direction:column;
    pointer-events:auto;
    position:absolute;
}
.icon
{
    width:64;
    height:64;
    font-size:42;
    border-radius:9px;
    box-shadow:4px 4px 5px;
    text-shadow:2px 2px 4px #000;
    background:linear-gradient(#fff,#777);
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
    white-space:nowrap;
    pointer-events:none;
}
.name
{
    top:70;
    font-size:17;
    color:#fff;
    text-shadow:2px 2px 5px #000;
    text-align:center;
    position:absolute;
    pointer-events:none;
}
.selected { background:linear-gradient(#fff,#44f); }
</style>
</template>
<template id=templateWindow>
<style>
:host
{
    box-shadow:9px 9px 9px;
    background:#000;
    border:2px solid;
    display:flex;
    flex-direction:column;
    overflow:hidden;
    position:absolute;
}
.titleBar
{
    height:44;
    font-size:30;
    background:linear-gradient(#999,#444);
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
    white-space:nowrap;
}
.frame
{
    width:100%;
    height:100%;
    border:none;
    background:#000;
    position:relative;
    overflow:hidden;
}
.name
{
    width:100%;
    cursor:grab;
    display:flex;
    align-items:center;
    overflow:hidden;
}
.codeDisplay
{
    height:100;
    resize:none;
    background:#000;
    color:#fff;
    display:none;
    user-select:auto;
    pointer-events:auto;
    border:1px solid #fff;
    outline:none;
}
.selected     { background:linear-gradient(#eee,#88f); }
.folder       { background:#000; }
.reload,
.full,
.code         { width:40; }
.code         { width:40; }
.close        { width:28; }
.code:hover   { background:#0f0; }
.full:hover   { background:#fff; }
.reload:hover { background:#ff0; }
.close:hover  { background:#f00; }
div svg       { width:100%; pointer-events:none; }
</style>    
<svg width=0 height=0>
<symbol id=icon-code viewBox='0 0 10 10'>
    <path stroke=#000 stroke-width=.7 fill=none d='M5 8L8 2L2 2L5 8L8 2' />
</symbol>
<symbol id=icon-full viewBox='0 0 10 10'>
    <rect stroke=#000 stroke-width=.7 fill=none x=1 y=2 width=8 height=6 />
</symbol>
<symbol id=icon-reload viewBox='0 0 10 10'>
    <circle stroke=#000 stroke-width=.7 fill=none cx=5 cy=5 r=3 />
</symbol>
<symbol id=icon-close viewBox='0 0 10 10'>
    <path stroke=#000 d='M1 1L9 9M9 1L1 9' />
</symbol>
</svg>
</template>
</head>
<body>
<div id=taskbar class=taskbar></div>
<div id=title class=title>OS13k</div>
<div id=desktop>
<script src=desktop.js?15></script>
<script>

// load test if there is no desktop
if (typeof desktopLayout == 'undefined')
    desktopLayout = [{src:'system/test.html'},{src:'dweets/underwaterCavern.dweet.js'}];

'use strict';

// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @language_out ECMASCRIPT_2019
// @js_externs OS13k, OS13kIcon, OS13kWindow, OS13kTaskbarIcon, zzfx, zzfxV
// @js_externs _OS13k.Medal, _OS13k.KeyDirection, _OS13k.Speak
// @js_externs _OS13k.CreateShader, _OS13k.RenderShader, _OS13k.CreateCanvas
// @js_externs _OS13k.PlaySamples, _OS13k.PlaySeedSound, _OS13k.GetSeedSound
// @js_externs _OS13k.Random, _OS13k.randomSeed 
// @js_externs _OS13k.Clamp, _OS13k.Percent, _OS13k.Lerp
// @js_externs iframeContent.OS13k, iframeContent.OS13kStart, iframeContent.zzfx
// @output_file_name OS13k.min.js
// ==/ClosureCompiler==

/////////////////////////////////////////////////////////////////////////////
// OS13k System

class _OS13k
{
    Start()
    {
        // init web audio
        this.audioContext = new (AudioContext || webkitAudioContext);
        this.audioContext.Z = this.audioContext.createBufferSource;
        this.audioContext.createBufferSource =
        (s = this.audioContext.Z())=>
        (
            s.start = s.start || s.noteOn,
            s.stop  = s.stop  || s.noteOff,
            s
        );
        
        // startup os13k
        this.randomSeed = Date.now();
        this.InitDesktop();
        setInterval(this.Update, 16);
    }
    
    InitDesktop()
    {
        // add close all icon
        const icon = {icon:'âŒ', name:'Close All'};
        this.taskbarIcon = new OS13kTaskbarIcon(desktop, icon);
        
        // add icons to desktop
        let x = 30, y = 80, open = 1;
        for (const icon of desktopLayout)
        {
            // set icon position
            icon.x = x;
            icon.y = y;
            if ((x += iconGridSizeX) > innerWidth - 70)
            {
                // wrap icons to fit window
                x = 30;
                y += iconGridSizeY;
            }
            
            // create icon
            const os13kicon = new OS13kIcon(icon);
            open && os13kicon.Open(open = 0);
        }
    }
    
    Update() 
    {
        // fit title to desktop
        title.style.fontSize = innerWidth/5;
        
        // listen for iframe becomming new active element
        const activeElement = document.activeElement;
        if (this.lastActiveElement != activeElement)
        {
            // set focus to new active element
            activeElement.Focus && activeElement.Focus();
            this.lastActiveElement = activeElement;
        }
    }
    
    KeyDirection(keyCode)
    {
        // get direction from wasd or arrow keys
        let x = 0, y = 0;
        if (keyCode == 87 || keyCode == 38) y += 1; // up
        if (keyCode == 83 || keyCode == 40) y -= 1; // down
        if (keyCode == 68 || keyCode == 39) x += 1; // right
        if (keyCode == 65 || keyCode == 37) x -= 1; // left
        return {x, y}
    }
    
    Medal(gameName, medalName='', difficulty=0)
    {
        // todo: show popup and unlock medal
    }
    
    PlaySeedSound(seed, lengthScale=1, volume=1, randomness=.05)
    {
        // set random seed
        this.randomSeed = seed;
        const R=()=> this.Random();
        
        // warm up random generator
        R(R(R()));
        
        // randomize sound length
        lengthScale /= 2;
        const attack  = R()**3*lengthScale;
        const sustain = R()**3*lengthScale;
        const release = R()**3*lengthScale;
        const length  = attack + sustain + release;
        
        // create random sound
        return zzfx(...
        [
           volume,                              // volume
           randomness,                          // randomness
           R()**2*2e3,                          // frequency
           attack,                              // attack
           sustain,                             // sustain
           release,                             // release
           R()*5|0,                             // shape
           R()**2*3,                            // shapeCurve
           (R()<.5) * R()**3*99*(R()<.5?-1:1),  // slide
           (R()<.5) * R()**3*99*(R()<.5?-1:1),  // deltaSlide
           (R()<.5) * R()**2*1e3*(R()<.5?-1:1), // pitchJump
           R()**2 * length,                     // pitchJumpTime
           (R()<.5) * R() * length,             // repeatTime
           (R()<.5) * R()**4,                   // noise
           (R()<.5) * R()**3*9*(R()<.5?-1:1),   // modulation
           (R()<.5) * R()**4,                   // bitCrush
           (R()<.5) * R()**3/2,                 // delay
        ]);
    }
    
    PlaySamples(samples, sampleRate=44100)
    {
        // play raw audio sample data
        const buffer = this.audioContext.createBuffer(1, samples.length, sampleRate);
        const source = this.audioContext.createBufferSource();
        buffer.getChannelData(0).set(samples);
        source.buffer = buffer;
        source.connect(this.audioContext.destination);
        source.start();
        return source;
    }
    
    Speak(text) { speechSynthesis.speak(new SpeechSynthesisUtterance(text)); }
    
    CreateShader(canvas, code)
    {
        // get webgl context
        const x = canvas.getContext('webgl2');

        // create a simple pass through vertex shader
        const vertexShader = x.createShader(x.VERTEX_SHADER);
        x.shaderSource(vertexShader,
            '#version 300 es\n' +
            'in vec4 p;' +
            'void main()' +
            '{gl_Position=p;}');
        x.compileShader(vertexShader);
        
        // create vertex buffer that is a big triangle
        const vertexBuffer = x.ARRAY_BUFFER;
        x.bindBuffer(vertexBuffer,x.createBuffer());
        x.bufferData(vertexBuffer,new Int8Array([-3,1,1,-3,1,1]),x.STATIC_DRAW);
        x.enableVertexAttribArray(0);
        x.vertexAttribPointer(0,2,x.BYTE,0,0,0); // 2D vertex
        
        // check vertex shader for errors
        //if (!x.getShaderParameter(vertexShader, x.COMPILE_STATUS))
        //    throw x.getShaderInfoLog(vertexShader);
        
        // create shadertoy compatible pixel shader
        const pixelShader = x.createShader(x.FRAGMENT_SHADER)
        const shaderProgramCode = 
            '#version 300 es\n' +
            'precision mediump float;' +
            'uniform float iTime;' +
            'uniform vec4 iMouse;' +
            'uniform vec3 iResolution;' +
            'uniform sampler2D iChannel0;' +
            'out vec4 outColor;\n' +
            code +
            '\nvoid main()' +
            '{mainImage(outColor,gl_FragCoord.xy);' +
            'outColor.a=1.;}';
        x.shaderSource(pixelShader, shaderProgramCode)
        x.compileShader(pixelShader);

        // check pixel shader for errors
        if (!x.getShaderParameter(pixelShader, x.COMPILE_STATUS))
            throw x.getShaderInfoLog(pixelShader);

        // create texture
        x.bindTexture(x.TEXTURE_2D, x.createTexture());
        x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MIN_FILTER, x.LINEAR);
        x.pixelStorei(x.UNPACK_FLIP_Y_WEBGL, 1); 
        
        // create shader program
        const shaderProgram = x.createProgram();
        x.attachShader(shaderProgram, vertexShader);
        x.attachShader(shaderProgram, pixelShader);
        x.linkProgram(shaderProgram);
        x.useProgram(shaderProgram);
        return shaderProgram;
    }
    
    RenderShader(canvas, shaderProgram, time=0)
    {
        // get webgl context
        const x = canvas.getContext('webgl2');
        
        // set uniforms
        const uniformLocation=name=>x.getUniformLocation(shaderProgram, name);
        x.uniform3f(uniformLocation('iResolution'), canvas.width, canvas.height, 1);
        x.uniform1f(uniformLocation('iTime'), time);
        x.uniform1i(uniformLocation('iChannel0'), 0);
        
        // render shader
        x.viewport(0, 0, canvas.width, canvas.height);
        x.drawArrays(x.TRIANGLE_FAN, 0, 3);
        
        // set texture to previous frame
        x.texImage2D(x.TEXTURE_2D, 0, x.RGBA, x.RGBA, x.UNSIGNED_BYTE, canvas);
    }
    
    // math functions
    Clamp(a, min=0, max=1) { return Math.min(Math.max(a, min),max); }
    Percent(v, a, b)       { return b-a? this.Clamp((v-a)/(b-a), 0, 1) : 0; }
    Lerp(p, a, b)          { return a + this.Clamp(p, 0, 1) * (b-a); }
    Random(max=1, min=0)
    {
        // seeded random numbers - Mersenne Twister
        this.randomSeed ^= (this.randomSeed||-1) << 13;
        this.randomSeed ^= this.randomSeed >> 17;
        this.randomSeed ^= this.randomSeed << 5;
        return this.Percent(Math.abs(this.randomSeed) % 1e9 / 1e9, min, max);
    }
}; // _OS13k

/////////////////////////////////////////////////////////////////////////////
// OS13k Desktop

desktop.Focus=()=>
{
    // deavtivate window and icons
    document.activeElement.blur();
    activeWindow && activeWindow.SetActive(activeWindow = 0);
    selectedTaskbarIcon && selectedTaskbarIcon.SetActive(selectedTaskbarIcon = 0);
    this.focus();
}

desktop.MouseDown=()=>desktop.Focus();

/////////////////////////////////////////////////////////////////////////////
// OS13kTaskbarIcon

let selectedTaskbarIcon;

class OS13kTaskbarIcon extends HTMLElement
{
	constructor(window, icon)
    {
		super();
        
        // add to taskbar
        taskbar.appendChild(this);
        
        // create icon
        this.window = window;
        this.className = 'icon';
        this.innerHTML = '<div style=pointer-events:none>' + icon.icon;
        this.title = icon.title;
    }
    
    MouseClick()
    {
        // focus on window
        desktop.Focus();
        this.window.Focus();
        if (this.window == desktop)
        {
            // close all windows
            const closeWindows = [];
            for( const c of desktop.children)
                c.Close && closeWindows.push(c);
            for( const w of closeWindows)
                w.Close();
                
            // reset window open position
            windowOpenX = 99;
            windowOpenY = 200;
        }
    }
    
    SetActive(active=1)
    {
        // unselect old icon and set style
        selectedTaskbarIcon && selectedTaskbarIcon.SetActive(selectedTaskbarIcon = 0);
        selectedTaskbarIcon = this;
        this.className = 'icon' + (active ? ' selected' : '');
    }
} // OS13kTaskbarIcon

customElements.define('os13k-taskbar-icon', OS13kTaskbarIcon);

/////////////////////////////////////////////////////////////////////////////
// OS13kIcon

let selectedIcon;
const iconGridSizeX = 99, iconGridSizeY = 120;

class OS13kIcon extends HTMLElement
{
	constructor({x, y, name, icon, src, width=720, height=405, author, folder, multiple, reload, code})
    {
		super();
        
        // add to desktop
        desktop.appendChild(this);
        
        // set icon defaults
        src = src || '';
        name = name || src.split('.')[0];
        icon = icon || (name[0] ? name[0].toUpperCase() : '' );
        
        
        // check for special extensions
        const extension = src? src.split('.')[1] : '';
        this.isDweet = extension == 'dweet';
        this.isShader = extension == 'shader';
        this.hasExtension = this.isDweet || this.isShader
        this.hasExtension && (reload = 1);
        
        // set icon data
        this.name = name;
        this.icon = icon;
        this.src = src;
        this.style.left = x;
        this.style.top = y;
        this.width = folder ? 420 : width;
        this.height = height;
        this.author = author;
        this.folder = folder;
        this.multiple = multiple;
        this.reload = reload;
        this.title = name + (author ? '\nBy ' + author : '');
        this.code = code || this.hasExtension;
        
        // create shadow root
		this.shadow = this.attachShadow({mode: 'open'});
        this.shadowRoot.innerHTML = templateIcon.innerHTML + 
            '<div class=name>' + name;
         
        // create icon
        const iconElement = this.iconElement = document.createElement('div');
        iconElement.className = 'icon';
        iconElement.innerHTML = icon;
        this.shadowRoot.appendChild(iconElement);
    }
    
    Open()
    {
        if (!this.window)
        {
            // create the window
            const window = new OS13kWindow(this);
            if (!this.multiple)
                this.window = window;
        }
        
        // set focus to window
        this.window && this.window.Focus();
    }
    
    MouseDown()
    {
        // focus on icon window if it exists and set active
        const parent = this.parentElement && this.parentElement.offsetParent;
        parent.Focus ? parent.Focus() : desktop.Focus();
    }
    
    MouseMove()
    {
        // set selected icon
        selected || ((selectedIcon = this).iconElement.className = 'icon selected');
    }
    
    MouseClick() 
    { 
        // open the window
        this.Open(); 
    }
    
} // OS13kIcon

customElements.define('os13k-icon', OS13kIcon);

/////////////////////////////////////////////////////////////////////////////
// OS13kWindow

let activeWindow, activeWindowZ = 0, windowOpenX = 99, windowOpenY = 200;

class OS13kWindow extends HTMLElement
{
	constructor(icon)
    {
		super();
        
        // add to desktop
        desktop.appendChild(this);
        
        // create taskbar icon
        this.icon = icon;
        this.taskbarIcon = new OS13kTaskbarIcon(this, icon);
        
        // set window position
        this.style.left = windowOpenX;
        this.style.top = windowOpenY;
        ((windowOpenY += 46) > 400) && (windowOpenY = 200);
        ((windowOpenX += 46) > 1e3) && (windowOpenX = 99);
        
        // create shadow root
		this.shadow = this.attachShadow({mode: 'open'});
        this.shadowRoot.innerHTML = templateWindow.innerHTML;
        
        // create title bar
        const titleBar = this.titleBar = document.createElement('div');
        titleBar.className = 'titleBar';
        this.shadowRoot.appendChild(titleBar);
        
        // create title bar name
        const titleBarName = document.createElement('div');
        titleBarName.className = 'name';
        titleBarName.innerHTML = 
            '<div style=pointer-events:none>' +
            '&nbsp;<span style="text-shadow:2px 2px 3px #000">' + 
            icon.icon + '</span>&nbsp;' +
            icon.name +
            (icon.author ? ' - ' + icon.author : '');
        titleBar.appendChild(titleBarName);
        
        // create title bar icons
        const AddTitleBarIcon=(id, title)=>
        {
            const icon = document.createElement('div');
            icon.innerHTML = `<svg><use href=#icon-${icon.className = id}>`;
            icon.title = title;
            titleBar.appendChild(icon);
        }
        icon.folder || AddTitleBarIcon('full', 'Full Screen');
        icon.code && AddTitleBarIcon('code', 'Show Code');
        icon.reload && AddTitleBarIcon('reload', 'Reload');
        AddTitleBarIcon('close', 'Close');
        
        // create thin black line below title bar
        const titleBarGap = document.createElement('div');
        titleBarGap.style.height = 2;
        this.shadowRoot.appendChild(titleBarGap);

        // create content wrapper
        const contentWrapper = this.contentWrapper = document.createElement('div');
        contentWrapper.className = 'frame folder';
        this.shadowRoot.appendChild(contentWrapper);
        
        // open the icon
        this.icon = icon;
        if (icon.folder)
        {
            // add icons to folder
            let x = 30, y = 30;
            for (const folderIcon of icon.folder)
            {
                folderIcon.x = x;
                folderIcon.y = y;
                if ((x += iconGridSizeX) > icon.width - 90)
                {
                    // wrap icons to fit window
                    x = 30;
                    y += iconGridSizeY;
                }
                contentWrapper.appendChild(new OS13kIcon(folderIcon));
            }
            
            // set folder color
            contentWrapper.style.background = '#222';
            
            // set focus
            this.Focus();
        }
        else if (icon.src)
        {
            // create iframe
            const iframe = this.iframe = document.createElement('iframe');
            iframe.className = 'frame';
            if (this.icon.hasExtension)
                iframe.style.display = this.icon.hasExtension ? 'none' : 'hidden';
            iframe.src = icon.src;
            contentWrapper.appendChild(iframe);
        
            // load frame
            iframe.onload=e=>
            {
                // set up iframe          
                const iframeContent = this.iframeContent = e.target.contentWindow;
                const iframeDocument = iframeContent.document;
                const iframeText = this.icon.hasExtension ?
                    iframeDocument.body.innerText :
                    iframeDocument.body.innerHTML;

                // create code display
                if (!this.codeDisplay)
                {
                    this.codeDisplay = document.createElement('textarea');
                    this.codeDisplay.className = 'codeDisplay'; 
                    this.codeDisplay.setAttribute('readOnly', 1);
                    this.codeDisplay.value = iframeText;
                    this.shadowRoot.appendChild(this.codeDisplay);
                }

                // try to pass OS13k to iframe
                iframeContent.OS13k = OS13k;
                iframeContent.zzfx = zzfx;
                iframeContent.oncontextmenu=e=>e.preventDefault();
                iframeContent.OS13kStart && iframeContent.OS13kStart(this.icon);

                // check for extensions
                if (this.icon.hasExtension)
                {
                    iframeDocument.body.innerHTML = 
                        '<canvas id=c width=1920 height=1080 style=' +
                        'width:100%;background:#' +
                        (this.icon.isDweet ? 'fff' : '000') +'>';
                    iframeDocument.body.style = 
                        'background:#111;' +
                        'overflow:hidden;' +
                        'margin:0;' +
                        'display:flex;' +
                        'align-items:center';

                    // create dweet
                    this.icon.isDweet && iframeContent.eval(
                        'u=t=>{' + iframeText + '};' +
                        'x=c.getContext`2d`;' +
                        'S=Math.sin;' +
                        'C=Math.cos;' +
                        'T=Math.tan;' +
                        'R=(r,g,b,a=1)=>`rgba(${0|r},${0|g},${0|b},${a})`;' +
                        'loop=t=>requestAnimationFrame(loop,' +
                            'document.hasFocus()&&' +
                            'u((60*(frame++/60)-frame-1|0?frame-1:frame)/60));' +
                        'loop(frame=0)');

                    // create shader
                    this.icon.isShader && iframeContent.eval(
                        'g=c.getContext`webgl2`;' +
                        'x=y=z=w=0;' +
                        'onmousemove=e=>e.buttons&&(x=e.x,y=c.height-e.y);' +
                        'onmousedown=e=>(x=z=e.x,y=w=c.height-e.y);' +
                        'onmouseup=e=>z=w=0;' +
                        'loop=t=>requestAnimationFrame(loop,' +
                            'document.hasFocus()&&(' +
                            'c.width=innerWidth,' + 
                            'c.height=innerHeight,' + 
                            'g.uniform4f(g.getUniformLocation(s,"iMouse"),x,y,z,w),' +
                            'OS13k.RenderShader(c,s,t/1e3)));' + 
                        'loop(s=OS13k.CreateShader(c,`' + iframeText + '`))');
                }
                
                // show iframe and set focus
                iframe.style.background = '#fff';
                iframe.style.display = '';
                this.Focus();
            }
        }
    }
    
    MouseDown(e, originalTarget)
    {
        if (originalTarget.className == 'codeDisplay')
            return;
            
        // prevent desktop from getting focus
        if (this.iframe)
            e.cancelable && e.preventDefault();
            
        // set selected
        if (originalTarget.className == 'name')
            selected = this;
            
        // set focus
        this.Focus();
    }
    
    MouseClick(e)
    {
        if (e.className == 'codeDisplay')
            return;
            
        // check for title bar buttons
        (e.className == 'full')   && this.FullScreen();
        (e.className == 'reload') && this.Reload();
        (e.className == 'close')  && this.Close();
        (e.className == 'code')  && this.ShowCode();
        this.Focus();
    }
    
    Close()
    {
        // destroy window
        this.icon.window = 0;
        this.taskbarIcon.remove();
        this.remove();
    }
    
    Reload()
    {
        // hide iframe and reload it
        this.iframe.style.display = this.icon.hasExtension ? 'none' : 'hidden';
        this.iframeContent.location.reload();
    }
    
    ShowCode()
    {
        this.showCode = !this.showCode;
        this.codeDisplay.style.display = this.showCode ? 'block' : '';
    }
    
    Focus()
    {
        // set focus
        this.iframeContent && this.iframeContent.focus();
        this.SetActive();
    }
    
    SetActive(active=1)
    {
        if (active && activeWindow != this)
        {
            // deactivate old window
            activeWindow && activeWindow.SetActive(0);
            
            // limit window size to inner size
            this.contentWrapper.style.width  = Math.min(this.icon.width,  innerWidth);
            this.contentWrapper.style.height = Math.min(this.icon.height, innerHeight);

            // clamp window to screen
            const rect = this.getBoundingClientRect();
            const maxHeight = Math.max(46,innerHeight-rect.height);
            this.style.left = OS13k.Clamp(rect.x, 0, innerWidth-rect.width);
            this.style.top = OS13k.Clamp(rect.y, 46, maxHeight);
                
            // move z to top and display
            this.style.zIndex = ++activeWindowZ;
            this.style.display = '';
        }
        
        // set active
        activeWindow = active && this;
        this.taskbarIcon.SetActive(1);
        this.titleBar.className = 'titleBar' + (active ? ' selected' : '');
    }
    
    FullScreen()
    {
        // set fullscreen
        const fullScreenElement = this.contentWrapper;
        if (fullScreenElement.webkitRequestFullScreen)
            fullScreenElement.webkitRequestFullScreen();
        else if (fullScreenElement.mozRequestFullScreen)
            fullScreenElement.mozRequestFullScreen();
    }
} // OS13kWindow

customElements.define('os13k-window', OS13kWindow);

/////////////////////////////////////////////////////////////////////////////
// Mouse Input

let selected, seletOffsetX, seletOffsetY;

onmousedown=e=>
{
    // prevent getting stuck
    if (selected) return onmouseup(e);
    
    // save selected offset
    const rect = e.target.getBoundingClientRect();
    seletOffsetX = e.x - rect.x;
    seletOffsetY = e.y - rect.y;
    
    // handle mouse down
    if (e.target.MouseDown)
        e.target.MouseDown(e, e.originalTarget || e.path[0])
    else
        desktop.MouseDown();
    
    if (selected)
    {
        // set grabbing mode
        document.body.style.cursor = 'grabbing';
        desktop.style.pointerEvents = 'none';
    }
}

onmouseup=e=>
{
    // allow pointer events and reset cursor
    desktop.style.pointerEvents = '';
    document.body.style.cursor = '';
        
    // release selected
    selected && selected.Focus();
    selected = 0;
}

onmousemove=e=>
{
    if (selected)
    {
        // update selected position
        selected.style.left = e.x - seletOffsetX;
        selected.style.top = e.y - seletOffsetY;
    }
    
    // unselect selected icon
    selectedIcon && (selectedIcon.iconElement.className = 'icon');
    
    // handle mouse move
    const originalTarget = e.originalTarget || e.path[0];
    originalTarget.MouseMove && originalTarget.MouseMove(e);
}

onclick=e=>
{
    // handle click
    const originalTarget = e.originalTarget || e.path[0];
    originalTarget.MouseClick ? originalTarget.MouseClick(originalTarget) :
        e.target.MouseClick && e.target.MouseClick(originalTarget);
}

// disable context menu
oncontextmenu=e=>e.preventDefault();

/////////////////////////////////////////////////////////////////////////////////////
// Touch Input

try
{
    let wasTouching, lastTouchTime;
    const ProcessTouch=e=>
    {
        const touching = e.touches.length;
        if (touching)
        {
            // set event pos
            e.x = e.touches[0].clientX;
            e.y = e.touches[0].clientY;
            
            // pass event on to mouse input
            if (!wasTouching)
                onmousedown(e);
            onmousemove(e);
            lastTouchTime = Date.now();
        }
        else
            wasTouching && (onmouseup(e), onclick(e));
        wasTouching = touching;
    }

    // set all touch events
    ontouchstart = ontouchmove = ontouchend = ontouchcancel = ProcessTouch;
}
catch (e) {}

/////////////////////////////////////////////////////////////////////////////
// ZzFXMicro - Zuper Zmall Zound Zynth 

let zzfxV  = .3; // volume
const zzfx =     // play zzfx sound
(
    volume        = 1, 
    randomness    = .05,
    frequency     = 220,
    attack        = 0,
    sustain       = 0,
    release       = .1,
    shape         = 0,
    shapeCurve    = 1,
    slide         = 0, 
    deltaSlide    = 0, 
    pitchJump     = 0, 
    pitchJumpTime = 0, 
    repeatTime    = 0, 
    noise         = 0,
    modulation    = 0,
    bitCrush      = 0,
    delay         = 0,

    // locals
    PI2 = Math.PI*2,
    sampleRate = 44100,
    random = r => r*2*Math.random()-r,
    sign = v => v>0?1:-1,
    startSlide = slide *= 500 * PI2 / sampleRate**2,
    startFrequency = frequency *= (1 + random(randomness)) * PI2 / sampleRate,
    modPhase = sign(modulation) * PI2/4,
    b=[], t=0, tm=0, i=0, j=1, r=0, c=0, s=0, d=.5,
    length, buffer
) =>
{
    // init parameters
    attack = 99 + attack * sampleRate | 0;
    sustain = sustain * sampleRate | 0;
    release = release * sampleRate | 0;
    delay = delay * sampleRate | 0;
    deltaSlide *= 500 * PI2 / sampleRate**3;
    length = attack + sustain + release + delay;
    modulation *= PI2 / sampleRate;
    pitchJump *= PI2 / sampleRate;
    pitchJumpTime = pitchJumpTime * sampleRate;
    repeatTime = repeatTime * sampleRate;

    // generate waveform
    for(; i < length;b[i++] = s)
    {
        if (++c > bitCrush*100)                          // bit crush
        {
            c = 0;
            s = t * frequency *                          // frequency
                Math.sin(tm * modulation - modPhase);    // modulation

            s = shape? shape>1? shape>2? shape>3?        // wave shape
                Math.sin((s%PI2)**3) :                   // 4 noise
                Math.max(Math.min(Math.tan(s),1),-1):    // 3 tan
                1-(2*s/PI2%2+2)%2:                       // 2 saw
                1-4*Math.abs(Math.round(s/PI2)-s/PI2):   // 1 triangle
                Math.sin(s);                             // 0 sin
            s = sign(s)*(Math.abs(s)**shapeCurve);       // curve 0=square, 2=pointy

            s *= volume * zzfxV * (                      // envelope
                i < attack ? i/attack :                  // attack
                i < attack + sustain ? 1 :               // sustain
                i < length - delay ?                     // post release
                1 - (i - attack - sustain)/release : 0); // release
                
            s = delay ?                                  // delay
                s/2 + (delay > i ? 0 :
                (i<length-delay? 1 : (i-length)/delay) * // release delay 
                b[i-delay]/2) : s;
        }

        t += 1 + random(noise);             // noise
        tm += 1 + random(noise);            // modulation noise
        frequency += slide += deltaSlide;   // frequency slide

        if (j && ++j > pitchJumpTime)       // pitch jump
        {
            frequency += pitchJump;         // apply pitch jump
            startFrequency += pitchJump;    // also apply to start frequency
            j = 0;                          // reset pitch jump time
        };

        if (repeatTime && ++r > repeatTime) // repeat
        {
            frequency = startFrequency;     // reset frequency
            slide = startSlide;             // reset slide
            r = 1;                          // reset repeat time
            j = j || 1;                     // reset pitch jump time
        }
    }
    
    return OS13k.PlaySamples(b);
}

/////////////////////////////////////////////////////////////////////////////
// Start OS13k!

const OS13k = new _OS13k;
OS13k.Start();

</script>